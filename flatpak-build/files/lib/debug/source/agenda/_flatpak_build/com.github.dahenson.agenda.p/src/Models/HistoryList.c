/* HistoryList.c generated by valac 0.54.3, the Vala compiler
 * generated from HistoryList.vala, do not modify */

#include <gtk/gtk.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <glib.h>

#if !defined(VALA_EXTERN)
#if defined(_MSC_VER)
#define VALA_EXTERN __declspec(dllexport) extern
#elif __GNUC__ >= 4
#define VALA_EXTERN __attribute__((visibility("default"))) extern
#else
#define VALA_EXTERN extern
#endif
#endif

#define AGENDA_TYPE_HISTORY_LIST (agenda_history_list_get_type ())
#define AGENDA_HISTORY_LIST(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), AGENDA_TYPE_HISTORY_LIST, AgendaHistoryList))
#define AGENDA_HISTORY_LIST_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), AGENDA_TYPE_HISTORY_LIST, AgendaHistoryListClass))
#define AGENDA_IS_HISTORY_LIST(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGENDA_TYPE_HISTORY_LIST))
#define AGENDA_IS_HISTORY_LIST_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), AGENDA_TYPE_HISTORY_LIST))
#define AGENDA_HISTORY_LIST_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), AGENDA_TYPE_HISTORY_LIST, AgendaHistoryListClass))

typedef struct _AgendaHistoryList AgendaHistoryList;
typedef struct _AgendaHistoryListClass AgendaHistoryListClass;
typedef struct _AgendaHistoryListPrivate AgendaHistoryListPrivate;
enum  {
	AGENDA_HISTORY_LIST_0_PROPERTY,
	AGENDA_HISTORY_LIST_NUM_PROPERTIES
};
static GParamSpec* agenda_history_list_properties[AGENDA_HISTORY_LIST_NUM_PROPERTIES];
#define _g_free0(var) (var = (g_free (var), NULL))

struct _AgendaHistoryList {
	GtkListStore parent_instance;
	AgendaHistoryListPrivate * priv;
};

struct _AgendaHistoryListClass {
	GtkListStoreClass parent_class;
};

static gpointer agenda_history_list_parent_class = NULL;

VALA_EXTERN GType agenda_history_list_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (AgendaHistoryList, g_object_unref)
VALA_EXTERN void agenda_history_list_add_item (AgendaHistoryList* self,
                                   const gchar* text);
VALA_EXTERN gchar** agenda_history_list_get_all_tasks (AgendaHistoryList* self,
                                           gint* result_length1);
static void _vala_array_add4 (gchar** * array,
                       gint* length,
                       gint* size,
                       gchar* value);
VALA_EXTERN AgendaHistoryList* agenda_history_list_new (void);
VALA_EXTERN AgendaHistoryList* agenda_history_list_construct (GType object_type);
static GObject * agenda_history_list_constructor (GType type,
                                           guint n_construct_properties,
                                           GObjectConstructParam * construct_properties);
static GType agenda_history_list_get_type_once (void);

void
agenda_history_list_add_item (AgendaHistoryList* self,
                              const gchar* text)
{
	GtkTreeIter iter = {0};
	gchar* row = NULL;
	gboolean valid = FALSE;
	GtkTreeIter _tmp0_ = {0};
	gboolean _tmp1_;
#line 31 "../src/Models/HistoryList.vala"
	g_return_if_fail (self != NULL);
#line 31 "../src/Models/HistoryList.vala"
	g_return_if_fail (text != NULL);
#line 34 "../src/Models/HistoryList.vala"
	_tmp1_ = gtk_tree_model_get_iter_first ((GtkTreeModel*) self, &_tmp0_);
#line 34 "../src/Models/HistoryList.vala"
	iter = _tmp0_;
#line 34 "../src/Models/HistoryList.vala"
	valid = _tmp1_;
#line 36 "../src/Models/HistoryList.vala"
	if (valid == FALSE) {
#line 87 "HistoryList.c"
		GtkTreeIter _tmp2_ = {0};
		GtkTreeIter _tmp3_;
#line 37 "../src/Models/HistoryList.vala"
		gtk_list_store_append ((GtkListStore*) self, &_tmp2_);
#line 37 "../src/Models/HistoryList.vala"
		iter = _tmp2_;
#line 38 "../src/Models/HistoryList.vala"
		_tmp3_ = iter;
#line 38 "../src/Models/HistoryList.vala"
		gtk_list_store_set ((GtkListStore*) self, &_tmp3_, 0, text, -1);
#line 98 "HistoryList.c"
	} else {
		GtkTreeIter _tmp8_ = {0};
		GtkTreeIter _tmp9_;
#line 40 "../src/Models/HistoryList.vala"
		while (TRUE) {
#line 104 "HistoryList.c"
			GtkTreeIter _tmp4_;
			gchar* _tmp5_ = NULL;
			const gchar* _tmp6_;
			gboolean _tmp7_;
#line 40 "../src/Models/HistoryList.vala"
			if (!valid) {
#line 40 "../src/Models/HistoryList.vala"
				break;
#line 113 "HistoryList.c"
			}
#line 41 "../src/Models/HistoryList.vala"
			_tmp4_ = iter;
#line 41 "../src/Models/HistoryList.vala"
			gtk_tree_model_get ((GtkTreeModel*) self, &_tmp4_, 0, &_tmp5_, -1);
#line 41 "../src/Models/HistoryList.vala"
			_g_free0 (row);
#line 41 "../src/Models/HistoryList.vala"
			row = _tmp5_;
#line 42 "../src/Models/HistoryList.vala"
			_tmp6_ = row;
#line 42 "../src/Models/HistoryList.vala"
			if (g_strcmp0 (_tmp6_, text) == 0) {
#line 44 "../src/Models/HistoryList.vala"
				gtk_list_store_remove ((GtkListStore*) self, &iter);
#line 129 "HistoryList.c"
			}
#line 50 "../src/Models/HistoryList.vala"
			_tmp7_ = gtk_tree_model_iter_next ((GtkTreeModel*) self, &iter);
#line 50 "../src/Models/HistoryList.vala"
			valid = _tmp7_;
#line 135 "HistoryList.c"
		}
#line 53 "../src/Models/HistoryList.vala"
		gtk_list_store_append ((GtkListStore*) self, &_tmp8_);
#line 53 "../src/Models/HistoryList.vala"
		iter = _tmp8_;
#line 54 "../src/Models/HistoryList.vala"
		_tmp9_ = iter;
#line 54 "../src/Models/HistoryList.vala"
		gtk_list_store_set ((GtkListStore*) self, &_tmp9_, 0, text, -1);
#line 145 "HistoryList.c"
	}
#line 31 "../src/Models/HistoryList.vala"
	_g_free0 (row);
#line 149 "HistoryList.c"
}

/**
         * Gets all tasks in the list
         *
         * @return Array of items from the list
         */
static void
_vala_array_add4 (gchar** * array,
                  gint* length,
                  gint* size,
                  gchar* value)
{
#line 72 "../src/Models/HistoryList.vala"
	if ((*length) == (*size)) {
#line 72 "../src/Models/HistoryList.vala"
		*size = (*size) ? (2 * (*size)) : 4;
#line 72 "../src/Models/HistoryList.vala"
		*array = g_renew (gchar*, *array, (*size) + 1);
#line 169 "HistoryList.c"
	}
#line 72 "../src/Models/HistoryList.vala"
	(*array)[(*length)++] = value;
#line 72 "../src/Models/HistoryList.vala"
	(*array)[*length] = NULL;
#line 175 "HistoryList.c"
}

gchar**
agenda_history_list_get_all_tasks (AgendaHistoryList* self,
                                   gint* result_length1)
{
	GtkTreeIter iter = {0};
	gboolean valid = FALSE;
	GtkTreeIter _tmp0_ = {0};
	gboolean _tmp1_;
	gchar** items = NULL;
	gchar** _tmp2_;
	gint items_length1;
	gint _items_size_;
	gchar** _tmp8_;
	gint _tmp8__length1;
	gchar** result = NULL;
#line 63 "../src/Models/HistoryList.vala"
	g_return_val_if_fail (self != NULL, NULL);
#line 65 "../src/Models/HistoryList.vala"
	_tmp1_ = gtk_tree_model_get_iter_first ((GtkTreeModel*) self, &_tmp0_);
#line 65 "../src/Models/HistoryList.vala"
	iter = _tmp0_;
#line 65 "../src/Models/HistoryList.vala"
	valid = _tmp1_;
#line 67 "../src/Models/HistoryList.vala"
	_tmp2_ = g_new0 (gchar*, 0 + 1);
#line 67 "../src/Models/HistoryList.vala"
	items = _tmp2_;
#line 67 "../src/Models/HistoryList.vala"
	items_length1 = 0;
#line 67 "../src/Models/HistoryList.vala"
	_items_size_ = items_length1;
#line 69 "../src/Models/HistoryList.vala"
	while (TRUE) {
#line 211 "HistoryList.c"
		gchar* text = NULL;
		GtkTreeIter _tmp3_;
		gchar* _tmp4_ = NULL;
		const gchar* _tmp5_;
		gchar* _tmp6_;
		gboolean _tmp7_;
#line 69 "../src/Models/HistoryList.vala"
		if (!valid) {
#line 69 "../src/Models/HistoryList.vala"
			break;
#line 222 "HistoryList.c"
		}
#line 71 "../src/Models/HistoryList.vala"
		_tmp3_ = iter;
#line 71 "../src/Models/HistoryList.vala"
		gtk_tree_model_get ((GtkTreeModel*) self, &_tmp3_, 0, &_tmp4_, -1);
#line 71 "../src/Models/HistoryList.vala"
		_g_free0 (text);
#line 71 "../src/Models/HistoryList.vala"
		text = _tmp4_;
#line 72 "../src/Models/HistoryList.vala"
		_tmp5_ = text;
#line 72 "../src/Models/HistoryList.vala"
		_tmp6_ = g_strdup (_tmp5_);
#line 72 "../src/Models/HistoryList.vala"
		_vala_array_add4 (&items, &items_length1, &_items_size_, _tmp6_);
#line 73 "../src/Models/HistoryList.vala"
		_tmp7_ = gtk_tree_model_iter_next ((GtkTreeModel*) self, &iter);
#line 73 "../src/Models/HistoryList.vala"
		valid = _tmp7_;
#line 69 "../src/Models/HistoryList.vala"
		_g_free0 (text);
#line 244 "HistoryList.c"
	}
#line 76 "../src/Models/HistoryList.vala"
	_tmp8_ = items;
#line 76 "../src/Models/HistoryList.vala"
	_tmp8__length1 = items_length1;
#line 76 "../src/Models/HistoryList.vala"
	if (result_length1) {
#line 76 "../src/Models/HistoryList.vala"
		*result_length1 = _tmp8__length1;
#line 254 "HistoryList.c"
	}
#line 76 "../src/Models/HistoryList.vala"
	result = _tmp8_;
#line 76 "../src/Models/HistoryList.vala"
	return result;
#line 260 "HistoryList.c"
}

AgendaHistoryList*
agenda_history_list_construct (GType object_type)
{
	AgendaHistoryList * self = NULL;
#line 24 "../src/Models/HistoryList.vala"
	self = (AgendaHistoryList*) g_object_new (object_type, NULL);
#line 24 "../src/Models/HistoryList.vala"
	return self;
#line 271 "HistoryList.c"
}

AgendaHistoryList*
agenda_history_list_new (void)
{
#line 24 "../src/Models/HistoryList.vala"
	return agenda_history_list_construct (AGENDA_TYPE_HISTORY_LIST);
#line 279 "HistoryList.c"
}

static GObject *
agenda_history_list_constructor (GType type,
                                 guint n_construct_properties,
                                 GObjectConstructParam * construct_properties)
{
	GObject * obj;
	GObjectClass * parent_class;
	AgendaHistoryList * self;
	GType* types = NULL;
	GType* _tmp0_;
	gint types_length1;
	gint _types_size_;
	GType* _tmp1_;
	gint _tmp1__length1;
#line 26 "../src/Models/HistoryList.vala"
	parent_class = G_OBJECT_CLASS (agenda_history_list_parent_class);
#line 26 "../src/Models/HistoryList.vala"
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
#line 26 "../src/Models/HistoryList.vala"
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, AGENDA_TYPE_HISTORY_LIST, AgendaHistoryList);
#line 27 "../src/Models/HistoryList.vala"
	_tmp0_ = g_new0 (GType, 1);
#line 27 "../src/Models/HistoryList.vala"
	_tmp0_[0] = G_TYPE_STRING;
#line 27 "../src/Models/HistoryList.vala"
	types = _tmp0_;
#line 27 "../src/Models/HistoryList.vala"
	types_length1 = 1;
#line 27 "../src/Models/HistoryList.vala"
	_types_size_ = types_length1;
#line 28 "../src/Models/HistoryList.vala"
	_tmp1_ = types;
#line 28 "../src/Models/HistoryList.vala"
	_tmp1__length1 = types_length1;
#line 28 "../src/Models/HistoryList.vala"
	gtk_list_store_set_column_types ((GtkListStore*) self, (gint) _tmp1__length1, _tmp1_);
#line 26 "../src/Models/HistoryList.vala"
	types = (g_free (types), NULL);
#line 26 "../src/Models/HistoryList.vala"
	return obj;
#line 322 "HistoryList.c"
}

static void
agenda_history_list_class_init (AgendaHistoryListClass * klass,
                                gpointer klass_data)
{
#line 24 "../src/Models/HistoryList.vala"
	agenda_history_list_parent_class = g_type_class_peek_parent (klass);
#line 24 "../src/Models/HistoryList.vala"
	G_OBJECT_CLASS (klass)->constructor = agenda_history_list_constructor;
#line 333 "HistoryList.c"
}

static void
agenda_history_list_instance_init (AgendaHistoryList * self,
                                   gpointer klass)
{
}

static GType
agenda_history_list_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (AgendaHistoryListClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) agenda_history_list_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (AgendaHistoryList), 0, (GInstanceInitFunc) agenda_history_list_instance_init, NULL };
	GType agenda_history_list_type_id;
	agenda_history_list_type_id = g_type_register_static (gtk_list_store_get_type (), "AgendaHistoryList", &g_define_type_info, 0);
	return agenda_history_list_type_id;
}

GType
agenda_history_list_get_type (void)
{
	static volatile gsize agenda_history_list_type_id__volatile = 0;
	if (g_once_init_enter (&agenda_history_list_type_id__volatile)) {
		GType agenda_history_list_type_id;
		agenda_history_list_type_id = agenda_history_list_get_type_once ();
		g_once_init_leave (&agenda_history_list_type_id__volatile, agenda_history_list_type_id);
	}
	return agenda_history_list_type_id__volatile;
}

